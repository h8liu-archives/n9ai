package tuai;

public class Court {
	public static int PLAYER_COUNT = 2;

	/**
	 * Create a court that the game of the court under a specific game.
	 * 
	 * @param game
	 *            The game module.
	 */
	public Court(Game game) {
		_game = game;
	}

	/**
	 * Run a game in default starting mode.
	 * 
	 * Exactly the same as: prepare((String) null)
	 */
	public void prepare() {
		prepare((String) null);
	}

	/**
	 * Prepare a game according to the startingMode. The playerCount and the
	 * initial piece will be generated by the game.
	 * 
	 * @param startingMode
	 *            The starting mode. null for default mode.
	 */
	public void prepare(String startingMode) {
		if (_game == null)
			return;
		_initial = _game.generateInit(startingMode);
	}

	/**
	 * Return the player count. This should not be invoked during the playing
	 * progress.
	 * 
	 * @return The count of players.
	 */
	public int getPlayerCount() {
		return PLAYER_COUNT;
	}

	/**
	 * Set the player to specified playerId, the former Player for this id will
	 * be replaced.
	 * 
	 * @param playerId
	 *            The specified player id, can be 0 or 1.
	 * @param player
	 *            The player.
	 */
	public void setPlayer(int playerId, Player player) {
		if (invalidId(playerId))
			return;
		_players[playerId] = player;
	}

	/**
	 * Run a game until the game is over or it is stopped by stop(). This should
	 * be only called after a prepare().
	 * 
	 * It may blocked if pause() is invoked during the game.
	 * 
	 * @return The winner's playerId. -1 for no winner. -2 for game is not set
	 *         or parameter not accepted. -3 for some player is not set. -4
	 *         Forcibly stopped.
	 */
	public int run() {
		for (int i = 0; i < PLAYER_COUNT; i++) {
			if (_players[i] == null)
				return -3;
		}

		if (_game == null)
			return -2;
		if (!_game.setInit(_initial))
			return -2;

		_stop = false;
		_winner = -1;

		/*
		 * all checking has passed now, no more return from here until the
		 * ending. of this function.
		 */

		// TODO: Log initial box
		for (int i = 0; i < PLAYER_COUNT; i++) {
			_players[i].launch();
		}

		setRound(0);

		while (_game.progress(_round) && !_stop) {
			Box share = _game.getShare();
			for (int i = 0; i < PLAYER_COUNT; i++) {
				Player current = _players[i];
				int timeLimit = _game.getTimeLimit(i);
				if (timeLimit > 0) {
					Box special = _game.getSpecial(i);
					current.setShare(share);
					current.setSpecial(special);
					Box reaction = current.getReaction(timeLimit);
					int timeUsed = (reaction == null) ? (-1) : (current
							.getLastTimeUsed());
					// TODO: Log reaction and timeUsed
					_game.setReaction(i, reaction, timeUsed);
					if (reaction == null)
						current.terminate();
				}
			}

			synchronized (_stepping) {
				try {
					if (_step)
						_stepping.wait();
				} catch (Exception e) {
					break;
				}
			}

			setRound(_round + 1);
		}

		for (int i = 0; i < PLAYER_COUNT; i++) {
			_players[i].terminate();
		}

		if (_stop) {
			return -4;
		}

		_winner = _game.getWinner();

		return _winner;
	}

	/**
	 * Stop a running game.
	 */
	public void stop() {
		synchronized (_stepping) {
			_stop = true;
			_stepping.notify();
		}
	}

	/**
	 * Continue a blocked game for one step.
	 */
	public void step() {
		synchronized (_stepping) {
			_stepping.notify();
		}
	}

	/**
	 * Turn on or turn off stepping mode. In stepping mode, the game will block
	 * and wait for a step() or a stop() each round.
	 * 
	 * @param step
	 *            Whether it is stepping.
	 */
	public void setStepping(boolean step) {
		synchronized (_stepping) {
			_step = step;
		}
	}

	private Game _game;
	private Player[] _players = new Player[PLAYER_COUNT];

	private int _winner = -1;
	private int _round = 0;
	private boolean _step = false;
	private boolean _stop = false;
	private Object _stepping = new Object();
	private Box _initial;

	private boolean invalidId(int playerId) {
		if (playerId < 0)
			return true;
		if (playerId > PLAYER_COUNT)
			return true;
		return false;
	}

	private void setRound(int round) {
		_round = round;
		for (int i = 0; i < PLAYER_COUNT; i++) {
			if (_players[i] != null)
				_players[i].setRound(round);
		}
	}
}
